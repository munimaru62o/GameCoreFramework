# アーキテクチャ概要

## 概要

本プロジェクト「GameCoreFramework (GCF)」は、Unreal Engine 5のモダンなアーキテクチャ（Lyra Starter Game等）を一度解体し、特定のゲームジャンルに依存しない**汎用的なゲームフレームワーク**として再設計したものです。

単に便利な機能を切り出すのではなく、マルチプレイ、ポゼッション（憑依）、途中参加（Late-joiner）、動的な機能注入といった **「実務で最も設計が破綻しやすい条件」** を前提としています。
「なぜ壊れるのか」「どこに責務の境界線を引くべきか」という問いに対する、一つのアーキテクチャ的な解答を目指しています。

---

## 🛑 解決する課題と目的

マルチプレイや複雑なプレイヤー挙動を扱うゲーム開発において、以下のような問題が頻発します。

- **曖昧な責務:** Pawn / Controller / PlayerState のどこにロジックを置くべきか迷い、神クラス（God Class）が生まれる。

- **初期化のレースコンディション:** Input / Ability / Camera が相互に依存し、ロード順の違いによってクラッシュする。

- **状態の同期不全:** ネットワーク遅延や途中参加（Late-joiner）によって、見た目と内部状態がずれる。

- **密結合の連鎖:** 入力とアビリティが直接結びついているため、アクターや操作キャラクターの差し替えが困難になる。

本プロジェクトでは、これらを **「運用（プログラマの注意力）で気をつける」のではなく、「仕組み（アーキテクチャ）で破綻させない」** 構成にすることを最大の目的としています。

### 💡 導入によるメリット

このフレームワークを採用することで、開発チームは以下の恩恵を受けられます。

- ポゼッションや途中参加を前提とした際の「どこに何を書くべきか」という迷いが消滅します。

- 初期化順序のバグや、システム間の複雑な依存関係を個別に調整する手間から解放されます。

- 「乗り物に乗る」「別のキャラクターに変身する」といった遊びを拡張しても、コア設計が壊れません。

---

## 📐 コアとなる設計方針

### 1. 魂（Player）と肉体（Pawn）の完全な分離
本フレームワークでは、永続的なデータと一時的な器の責務を明確に分離しています。

- **Player（魂 / 永続的）:**
  肉体（Pawn）を乗り換えても維持されるステータスや、永続的な能力（Ability）を定義します（主にPlayerStateが担います）。
  肉体への「憑依（Possession）」をトリガーとして、その肉体が持つ機能をアクティベートします。

- **Pawn（肉体 / 一時的）:**
  物理的な存在であり、その「ガワ」が持つべき固有の能力や入力バインドのみを定義します。（例：車なら「加速・ブレーキ」、人間なら「ジャンプ・歩行」）。

この分離により、ポゼッションを伴うゲームでもロジックが破綻せず、肉体を切り替える遊びを自然に実装できます。

### 2. イベント駆動と状態ベースのハイブリッド化
当初は設計をイベント駆動（Delegate等による通知）のみで行っていましたが、「途中参加者（Late-joiner）に過去のイベントが届かない」「OnPossessed などの一瞬のイベントに依存すると初期化順序でクラッシュする」という非同期マルチプレイ特有の限界に直面しました。

そこで、GameFrameworkComponentManager（GFCM）の `InitState` を活用し、**イベントではなく「状態（State）」として扱うハイブリッド構成** へ移行しました。「データ・ポゼッション・ロジックが全て揃うまで次の状態へ進まない」という厳格なゲート制御により、「いつ参加しても、その時の状態で現在の状況を完全に再現できる」強固な構造を実現しています。

### 3. データ駆動による遊びの拡張
挙動や能力をC++コードにハードコーディングせず、データアセットのバリエーションによって遊びの幅を広げられる設計を採用しています。Pawn構成やAbility構成をゲーム性に応じて柔軟に切り替え可能です。

### 4. Tickレス設計によるベース・オーバーヘッドの最小化
本フレームワークは、根本的に **イベント駆動モデル（Event-Driven Model）** の上に構築されており、各コンポーネントにおける毎フレームのTick処理（`PrimaryComponentTick.bCanEverTick = true`）への依存を厳格に排除しています。
Gameplay MessageやComponent Extension Event、マルチキャストデリゲートと深く統合することで、無駄な状態監視（ポーリング）を削減しました。

これにより、フレームワークそのものが消費する **ベースラインのCPUオーバーヘッドを極限までゼロに近づけ** 、スケーラビリティを最大化しています。結果として、複雑なゲームプレイロジックや多数のアクターが混在する物理シミュレーションに対して、十分なCPUリソース（ヘッドルーム）を確保できる設計となっています。

---

## ✨ 本フレームワークの独自機能

### 1. Dual ASC構成とタグベースのルーティング
一般的なGAS（Gameplay Ability System）の設計では、ASC（Ability System Component）は PlayerState か Pawn の「どちらか一方」に持たせるのがセオリーです。しかし本フレームワークでは、永続的な能力と乗り換え可能な能力を完全に分離するため、 **PlayerState（魂）と Pawn（肉体）の両方にASCを持たせる（Dual ASC構成）** というアーキテクチャを採用しています。

この特殊な構成において最大の技術的課題となるのが、「プレイヤーの入力（ボタン押下）を、魂と肉体のどちらのASCに発火させるべきか？」という入力のルーティング問題です。
入力が特定のAbilityクラスやASCを直接参照する密結合を排除するため、本フレームワークでは `InputBridge` と `AbilityRouter` を構築しました。

`UGCFAbilityInputRouterComponent` は、入力時に渡されるタグの階層に基づき、以下のルールで入力を自動的に振り分けます。
- 🟢`Ability.Player.*` のタグが来た場合 
    - **PlayerState の ASC** へルーティング (インタラクトなど、魂の永続的な能力として処理)

- 🟠`Ability.Pawn.*` のタグが来た場合 
    - **Pawn の ASC** へルーティング （ジャンプや射撃など、現在の肉体に依存する能力として処理）

これにより、入力側（ControllerやInputComponent）は「誰のASCか」を一切知る必要がなく、 **単に「タグ」を投げるだけで処理主体を動的に切り替える** ことが可能になっています。

### 2. 次世代ネットワーク同期 (NPP / Mover) のラグ対策と最適化
Unreal Engine 5の次世代ネットワーク同期基盤である Network Prediction Plugin (NPP) および Mover プラグインを実戦投入するにあたり、エンジン内部の仕様に起因する致命的な同期ズレや予測の暴走を、本システム独自のアーキテクチャ設計によって解決しています。

- **ハイブリッド環境における Clock Sync の維持（Adapterパターンの採用）**  
  旧来の `CharacterMovementComponent` (CMC) と新しい `Mover` が混在するゲーム環境において、NPPのシミュレーション時計（Clock）はシステムごとに孤立してスリープする仕様があります。これにより、プレイヤーがCMCを操作している際、他者のMover（ドローンなど）のネットワークパケットが「未来のデータ」として破棄され、フリーズする問題（Extrapolation Starvation）が発生します。
  本システムでは、常にサーバーと通信を行う `PlayerController` 側に **「物理干渉を持たない軽量なダミーMover」** をAdapterとして持たせることで、プレイヤーがどのPawnに憑依していてもNPPの時計をグローバルに同期し続ける強固なインフラを構築しています。

- **予測の暴走（Extrapolation Runaway）を安全に防ぐ入力サニタイズ**  
  Moverの Simulated Proxy（他プレイヤーのキャラクター）は、通信のパケットロスが発生した際、最後に届いた入力データを使い回して未来の位置を予測（Extrapolation）します。しかし、飛行状態など摩擦の少ない状況下では、この「古い入力」によってキャラクターが無限に加速・前進し続け、パケット到達時に強烈な引き戻し（Rubber-banding）を引き起こします。
  本システムでは、NPPのコアバッファを汚染することなく、毎フレーム生成される **「予測計算用の使い捨て入力スナップショット」の方向ベクトルのみを直前で強制クリア** するハックを実装しています。これにより、NPPの巻き戻し（Rollback）の安全性を完全に担保したまま、ラグ環境下における致命的なOvershootingを防止しています。

---

## 🛠 開発者体験 (DX): 複雑な内部構造を隠蔽したシンプルな拡張性

本フレームワークは、内部的に極めて複雑な非同期処理やルーティングを行っていますが、**実際にゲームプレイを実装するプログラマやプランナー（利用者）に対しては、その複雑さを完全に隠蔽（カプセル化）** しています。

新しい機能を追加する際、利用者は既存のコアコードを一切改修する必要がなく、以下の極めてシンプルな手順のみで安全に拡張が可能です。

### 例1: プランナーによる新しいアビリティと入力の紐付け (データ駆動)
C++のコードは1行も記述する必要がありません。「能力の定義」と「物理入力」を分離した2つのDataAssetを設定するだけで、システムが自動的に適切なASC（魂か肉体か）を判定してルーティングを行います。

#### 1. アビリティに「入力タグ」を割り当てる (`UGCFAbilitySet`)
対象に付与するアビリティセットを開き、以下の要素をセットします。

- **Granted Gameplay Abilities:** 
  - **Ability:** `GA_Jump` （追加したいアビリティクラス）
  - **InputTag:** `InputTag.Ability.Pawn.Jump` （プレフィックスにより対象ドメインを自動決定）

#### 2. 物理的な操作（InputAction）とタグを紐付ける (`UGCFInputConfig`)
入力設定を開き、Unreal標準のInputActionと、上記で定義したタグを紐付けるだけです。

- **Ability Input Actions:**
  - **InputAction:** `IA_Jump` （スペースキーやボタンなどの物理入力）
  - **GameplayTag:** `InputTag.Ability.Pawn.Jump`

### 例2: プログラマによる「新しい乗り物」の追加 (Interface駆動)
例えば、全く新しい物理挙動を持つ「ホバーボード」を追加したい場合、コントローラー側の入力処理（`Input_Move`等）を書き換える必要はありません。
新しいPawnクラスに `IGCFLocomotionHandler` インターフェースを実装し、受け取った普遍的なベクトルを独自の推進力に変換するだけです。

```cpp
// AGCFHoverboardPawn.cpp
// インターフェース関数をオーバーライドするだけで、コントローラーからの汎用的な操作を受け付ける
void AGCFHoverboardPawn::HandleMoveInput(const FVector& MovementVector)
{
    // コントローラーが計算した「進みたい方向(MovementVector)」を受け取り、
    // ホバーボード特有の物理スラスター処理などに変換するだけ
    HoverThrusterComponent->AddForce(MovementVector * HoverThrustPower);
}
```

このように、「アーキテクチャのルールの内側」に乗るだけで、誰でも安全かつ最速で機能量産を行える土台を提供しています。

---

## 🎯 非ゴールと対象スコープ

### 設計思想：速度よりも堅牢性（Robustness over Speed）

本フレームワークは、プロトタイピングの初速よりも、 **「中長期的な拡張性（Scalability）」** と **「決定論的な挙動（Deterministic Behavior）」** の担保を設計の最優先事項としています。

ボタンを1つ追加するために「DataAssetの作成」「タグの付与」といった明確な手順（ルール）を要求します。そのため、初期のセットアップや学習には一定のコストを要しますが、この強制された構造により、 **「100個目のアビリティ追加」も「1個目の追加」と全く同じ安全性と秩序を持って行うことが可能** になります。

中長期的な仕様変更や、数十人規模でのコンテンツ量産フェーズに入った際、この「壊れない土台」によるイテレーション速度は、結果的に従来のプロトタイプ型開発を大きく凌駕します。

**【最も価値を発揮するプロジェクト】**
- 大規模マルチプレイヤーゲームや、数年単位での運用を見据えた長期運営型タイトル
- コンテンツ量産時に、プログラマのQA（デバッグ）コストを劇的に削減したいチーム
- 「乗り物への搭乗」や「キャラクターの動的な変更（Possession）」をコアメカニクスとするゲーム

**【オーバーエンジニアリングとなる可能性のあるプロジェクト】**
- 拡張性を考慮せず、数週間で使い捨てる予定のモックアップ開発
- 単一Pawn・単一視点のみで完結し、マルチプレイや状態遷移を一切想定しない小規模なゲーム

---

## 🚀 今後の展望とロードマップ (Roadmap & Future Integrations)

本フレームワークは、初期フェーズにおいて「コア基盤の堅牢性（責務分離、非同期ライフサイクル、ルーティングの確立）」の証明を最優先課題としました。そのため、 **ロジック（Model）の動作には直接影響しない「見た目の装飾（Cosmetic）」や「特定のゲーム体験（Experience）に依存する機能」を意図的に削ぎ落とした、最小構成（MVP）** として構築しています。

強固なルーティング基盤とライフサイクル管理が完成した現在、次なるフェーズとして、この骨組みの上に以下の機能を **疎結合なモジュール（GameFeatureや独立したコンポーネント）として統合していく** 予定です。

**【今後の実装予定モジュール】**
- **User Facing Experience & UI Routing:** `CommonUI` や `CommonGame` を本格的に統合し、タイトル画面からインゲームへのシームレスな遷移、およびExperienceごとの動的なアセット読み込み（PrimaryAssetLabelの活用）基盤の構築。

- **Cosmetic & Feedback System:** Gameplay Ability Systemの `GameplayCue` などを活用し、ロジックを汚染することなく、キャラクターのアニメーション、VFX、サウンドなどの視覚的・聴覚的フィードバックを動的に付与する仕組みの統合。

- **Equipment & Inventory System:** 武器やアイテムの装備状態を管理し、動的にアビリティを付与するシステム。

---

*※ 本プロジェクトは現在も変容段階にあり、現時点での設計が最終解ではありません。今後の実装や検証によって、設計や責務分離の形はさらに進化していく前提です。*
