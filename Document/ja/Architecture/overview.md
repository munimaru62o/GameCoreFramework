# アーキテクチャ概要

## 概要

本プロジェクト「GameCoreFramework (GCF)」は、Unreal Engine 5のモダンなアーキテクチャ（Lyra Starter Game等）を一度解体し、特定のゲームジャンルに依存しない**汎用的なゲームフレームワーク**として再設計したものです。

単に便利な機能を切り出すのではなく、マルチプレイ、ポゼッション（憑依）、途中参加（Late-joiner）、動的な機能注入といった**「実務で最も設計が破綻しやすい条件」**を前提としています。
「なぜ壊れるのか」「どこに責務の境界線を引くべきか」という問いに対する、一つのアーキテクチャ的な解答を目指しています。

---

## 🛑 解決する課題と目的

マルチプレイや複雑なプレイヤー挙動を扱うゲーム開発において、以下のような問題が頻発します。

- **曖昧な責務:** Pawn / Controller / PlayerState のどこにロジックを置くべきか迷い、神クラス（God Class）が生まれる。

- **初期化のレースコンディション:** Input / Ability / Camera が相互に依存し、ロード順の違いによってクラッシュする。

- **状態の同期不全:** ネットワーク遅延や途中参加（Late-joiner）によって、見た目と内部状態がずれる。

- **密結合の連鎖:** 入力とアビリティが直接結びついているため、アクターや操作キャラクターの差し替えが困難になる。

本プロジェクトでは、これらを**「運用（プログラマの注意力）で気をつける」のではなく、「仕組み（アーキテクチャ）で破綻させない」**構成にすることを最大の目的としています。

### 💡 導入によるメリット

このフレームワークを採用することで、開発チームは以下の恩恵を受けられます。

- ポゼッションや途中参加を前提とした際の「どこに何を書くべきか」という迷いが消滅します。

- 初期化順序のバグや、システム間の複雑な依存関係を個別に調整する手間から解放されます。

- 「乗り物に乗る」「別のキャラクターに変身する」といった遊びを拡張しても、コア設計が壊れません。

---

## 📐 コアとなる設計方針

### 1. 魂（Player）と肉体（Pawn）の完全な分離
本フレームワークでは、永続的なデータと一時的な器の責務を明確に分離しています。

- **Player（魂 / 永続的）:**
  肉体（Pawn）を乗り換えても維持されるステータスや、永続的な能力（Ability）を定義します（主にPlayerStateが担います）。
  肉体への「憑依（Possession）」をトリガーとして、その肉体が持つ機能をアクティベートします。

- **Pawn（肉体 / 一時的）:**
  物理的な存在であり、その「ガワ」が持つべき固有の能力や入力バインドのみを定義します。（例：車なら「加速・ブレーキ」、人間なら「ジャンプ・歩行」）。

この分離により、ポゼッションを伴うゲームでもロジックが破綻せず、肉体を切り替える遊びを自然に実装できます。

### 2. イベント駆動と状態ベースのハイブリッド化
当初は設計をイベント駆動（Delegate等による通知）のみで行っていましたが、「途中参加者（Late-joiner）に過去のイベントが届かない」「OnPossessed などの一瞬のイベントに依存すると初期化順序でクラッシュする」という非同期マルチプレイ特有の限界に直面しました。

そこで、GameFrameworkComponentManager（GFCM）の `InitState` を活用し、**イベントではなく「状態（State）」として扱うハイブリッド構成**へ移行しました。「データ・ポゼッション・ロジックが全て揃うまで次の状態へ進まない」という厳格なゲート制御により、「いつ参加しても、その時の状態で現在の状況を完全に再現できる」強固な構造を実現しています。

### 3. データ駆動による遊びの拡張
挙動や能力をC++コードにハードコーディングせず、データアセットのバリエーションによって遊びの幅を広げられる設計を採用しています。Pawn構成やAbility構成をゲーム性に応じて柔軟に切り替え可能です。

### 4. Tickレス設計によるベース・オーバーヘッドの最小化
本フレームワークは、根本的に**イベント駆動モデル（Event-Driven Model）**の上に構築されており、各コンポーネントにおける毎フレームのTick処理（`PrimaryComponentTick.bCanEverTick = true`）への依存を厳格に排除しています。
Gameplay MessageやComponent Extension Event、マルチキャストデリゲートと深く統合することで、無駄な状態監視（ポーリング）を削減しました。

これにより、フレームワークそのものが消費する **ベースラインのCPUオーバーヘッドを極限までゼロに近づけ** 、スケーラビリティを最大化しています。結果として、複雑なゲームプレイロジックや多数のアクターが混在する物理シミュレーションに対して、十分なCPUリソース（ヘッドルーム）を確保できる設計となっています。

---

## ✨ 本フレームワークの独自機能

### Dual ASC構成とタグベースのルーティング
一般的なGAS（Gameplay Ability System）の設計では、ASC（Ability System Component）は PlayerState か Pawn の「どちらか一方」に持たせるのがセオリーです。しかし本フレームワークでは、永続的な能力と乗り換え可能な能力を完全に分離するため、**PlayerState（魂）と Pawn（肉体）の両方にASCを持たせる（Dual ASC構成）**というアーキテクチャを採用しています。

この特殊な構成において最大の技術的課題となるのが、「プレイヤーの入力（ボタン押下）を、魂と肉体のどちらのASCに発火させるべきか？」という入力のルーティング問題です。
入力が特定のAbilityクラスやASCを直接参照する密結合を排除するため、本フレームワークでは `InputBridge` と `AbilityRouter` を構築しました。

`UGCFAbilityInputRouterComponent` は、入力時に渡されるタグの階層に基づき、以下のルールで入力を自動的に振り分けます。
- 🟢`Ability.Player.*` のタグが来た場合 
    - **PlayerState の ASC** へルーティング (インタラクトなど、魂の永続的な能力として処理)

- 🟠`Ability.Pawn.*` のタグが来た場合 
    - **Pawn の ASC** へルーティング （ジャンプや射撃など、現在の肉体に依存する能力として処理）

これにより、入力側（ControllerやInputComponent）は「誰のASCか」を一切知る必要がなく、**単に「タグ」を投げるだけで処理主体を動的に切り替える**ことが可能になっています。

---

## 🎯 非ゴールと対象スコープ

### 設計思想：速度よりも堅牢性（Robustness over Speed）
本フレームワークは、プロトタイピングの速度よりも、**「拡張性（Scalability）」**と**「決定論的な挙動（Deterministic Behavior）」**を明確に優先しています。
ボタンを1つ追加するために複数の手順（DataAssetの作成、タグの付与等）が必要になりますが、この強制された構造により、「100個目のアビリティ追加」も「1個目の追加」と同じ安全性と秩序を持って行えるようになり、プロジェクトのスパゲッティコード化を防ぎます。

**【向いているプロジェクト】**
- 大規模マルチプレイヤーゲームや長期運営型タイトル
- ゲーム性に応じてPawn構成を柔軟に変えたい開発者
- マルチプレイやPossessionを前提とした堅牢な設計を求めている人

**【向いていないプロジェクト】**
- 即席で動けばよいプロトタイプ（初期セットアップの学習コストがかかります）
- 単一Pawn・単一視点のみを想定したシンプルなゲーム
- UE公式実装の完全な置き換え

---

## 🚀 今後の展望とロードマップ (Roadmap & Future Integrations)

本フレームワークは、初期フェーズにおいて「コア基盤の堅牢性（責務分離、非同期ライフサイクル、ルーティングの確立）」の証明を最優先課題としました。そのため、**ロジック（Model）の動作には直接影響しない「見た目の装飾（Cosmetic）」や「特定のゲーム体験（Experience）に依存する機能」を意図的に削ぎ落とした、最小構成（MVP）**として構築しています。

強固なルーティング基盤とライフサイクル管理が完成した現在、次なるフェーズとして、この骨組みの上に以下の機能を**疎結合なモジュール（GameFeatureや独立したコンポーネント）として統合していく**予定です。

**【今後の実装予定モジュール】**
- **User Facing Experience & UI Routing:** `CommonUI` や `CommonGame` を本格的に統合し、タイトル画面からインゲームへのシームレスな遷移、およびExperienceごとの動的なアセット読み込み（PrimaryAssetLabelの活用）基盤の構築。

- **Cosmetic & Feedback System:** Gameplay Ability Systemの `GameplayCue` などを活用し、ロジックを汚染することなく、キャラクターのアニメーション、VFX、サウンドなどの視覚的・聴覚的フィードバックを動的に付与する仕組みの統合。

- **Equipment & Inventory System:** 武器やアイテムの装備状態を管理し、動的にアビリティを付与するシステム。

---

*※ 本プロジェクトは現在も変容段階にあり、現時点での設計が最終解ではありません。今後の実装や検証によって、設計や責務分離の形はさらに進化していく前提です。*
