// Copyright (c) 2026 62o. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.

#include "Movement/Mover/GCFFlyingMode.h"
#include "MoverComponent.h"
#include "MoverDataModelTypes.h"


void UGCFFlyingMode::GenerateMove_Implementation(const FMoverTickStartData& StartState, const FMoverTimeStep& TimeStep, FProposedMove& OutProposedMove) const
{
    if (GetMoverComponent() && GetMoverComponent()->GetOwnerRole() == ROLE_SimulatedProxy) {
		if (FCharacterDefaultInputs* InputData = StartState.InputCmd.InputCollection.FindMutableDataByType<FCharacterDefaultInputs>()) {
			// [Architectural Note on Network Prediction Extrapolation]
			// Forcefully clear the stale directional input with a zero vector.
			//
			// WHY THIS IS NECESSARY:
			// NPP extrapolates movement for Simulated Proxies using the last received input during packet drops.
			// In low-friction modes like Flying, this "stale input" causes extreme overshooting (Extrapolation Runaway),
			// leading to severe rubber-banding when the correct SyncState finally arrives.
			//
			// WHY THIS IS SAFE:
			// The 'StartState' passed here is a per-tick COPY (snapshot) generated by the NPP backend, 
			// not the historical rollback buffer itself. 
			// Mutating 'InputData' here DOES NOT corrupt the prediction history or rollback state.
			// It purely forces this specific simulation tick (Super::GenerateMove) to calculate physics 
			// with zero input (relying only on inertia and deceleration), cleanly preventing overshooting.

			InputData->SetMoveInput(EMoveInputType::DirectionalIntent, FVector::ZeroVector);
		}
    }

	// Execute the standard physics calculation using the sanitized/safe start state.
	Super::GenerateMove_Implementation(StartState, TimeStep, OutProposedMove);
}